:stem: latexmath
:icons: font
:icon-set: octicon
:imagesdir: ./images
:source-highlighter: rouge
:source-language: python
:rouge-css: style
:rouge-linenums-mode: inline
:rouge-style: github
:chapter-label: Lesson
:table-caption: Table
:listing-caption: Program
:example-caption: Exercise
:xrefstyle: short
:sectnums:
:experimental:
:pi: &#960;
ifndef::audience[]
:audience: whitworth
endif::audience[]
= Quadratic fits and Excel files

Some data acquisition programs will output their results in Microsoft Excel formats (either the older `.xls` format or the current `.xlsx` format). The pandas library is able to interpret either of these formats (plus several other common spreadsheet formats). This lesson also demonstrates how `prettyPolyFit` can be applied to fitting higher order polynomials.

By the end of this lesson you will be able to:

* Create a data file in Excel and upload it to GitHub
* Import an Excel-formatted data file into Colab
* Find the parameters of a best fit quadratic curve using `whit_phys_util.prettyPolyFit`
* Add a best fit curve to a graph using the function generated by `whit_phys_util.prettyPolyFit`
* Automate tasks using a `for` loop

== Creating and uploading an Excel workbook

ifeval::[{audience} == whitworth]
. Go to Blackboard and look for the assignment corresponding to this lesson. This will have a link that will take you to the assignment on GitHub Classroom.
endif::[]
// End of Whitworth-specific block
. Start Excel.
. Right-click on the sheet name (`Sheet1`) and select **Rename**. Change its name to `Trial 1`.
. In cell A1 type `Time (s)`. In cell B1 type `Height (m)`.
. Type `0` in cell A2 and `0.25` in cell A3.
. Select cells A2 and A3. Move the cursor to the lower right corner where it will switch from being an arrow to a plus symbol. Drag down to cell A10.
. In this situation, Excel figured out a pattern based on the two selected cells and then continued that pattern to put the appropriate **values** in those cells. Click on cell A5 to verify that it contains a value, not a formula.
. Although pandas has a smart importer for Excel workbooks that can handle either values or formulas, it is a prudent habit to use values if a formula is not required. As of fall 2020 the importer for Google Sheets (a topic for another lesson) would fail to behave as expected if a formula (something like `=A2+0.25`) was used to create the values in column A.
. Now add values to column B so your sheet looks like the following:
+
[cols="1,1"]
|===
| Time (s) | Height (m)

| 0 | 1.99
| 0.25 | 3.95
| 0.5 | 5.24
| 0.75 | 5.97
| 1 | 6.12
| 1.25 | 5.6
| 1.5 | 4.51
| 1.75 | 2.77
| 2 | 0.42
|===
. Add a new sheet (click on the icon:plus-circle[]) and then change its name to `Trial 2`.
. On the new sheet, type `Time (s)` in A1 and `Height (m)` in B1.
. The time values are the same as on the previous sheet so you can use the standard Excel copy sequence (select cells A2 to A10 on the _Trial 1_ sheet, type kbd:[Ctrl + C], switch to the _Trial_ sheet, select cell A2, and then type kbd:[Enter]).
. Now add values to column B so your sheet looks like the following:
+
[cols="1,1"]
|===
| Time (s) | Height (m)

| 0 | 1.61
| 0.25 | 3.84
| 0.5 | 5.66
| 0.75 | 6.82
| 1 | 7.48
| 1.25 | 7.54
| 1.5 | 7.11
| 1.75 | 5.78
| 2 | 3.73
|===
. Save this Excel workbook somewhere on your computer with the name `height-vs-time-data.xlsx`. When you are done, close Excel.
. Open the lesson repository on GitHub.
. Select menu:Add file[Upload files].
. Drag the Excel workbook file to the "`drop zone`" or use the **choose your files** link.
. Click on btn:[Commit changes] to complete the upload.

== Importing a sheet from an Excel workbook

. Open the Colab notebook for this lesson from your GitHub repository.
. Execute the Code cells in the **Install and Import Libraries** section.
. In the **Connect to GitHub repository** section, place the URL of your GitHub repository for this lesson inside of the quotation marks in the argument for the `buc.local_repository` command. After you have done this, process the cell.
. Create a Text cell with the section header `# Trial 1`.
. Create another Text cell with a second-level section heading `## Import Excel sheet`.
. Now add a Code cell with the following to import the first sheet in the Excel workbook into its own DataFrame object:
+
[source,python]
----
df1 = pd.read_excel("height-vs-time-data.xlsx","Trial 1")
df1
----
. Notice that this time we have given the DataFrame the name `df1` because there will be more than one DataFrame in this notebook. It could also have been called something like `trial1` (there is no need to give it a name that includes `df`).


== Plotting and fitting the data

. Create a Text cell and give it the second-level section header `## Data analysis`.
. Create and process a Code cell with the following:
+
[source,python]
----
fig1, ax1 = plt.subplots()
ax1.plot(df1['Time (s)'], df1['Height (m)'], 'D');
----
+
Notice that this time we have given the Figure and Axes objects slightly longer names because there will be more than one graph in this notebook.
. Edit the code cell for this graph and add the commands to label the axes. Also adjust the limits of the vertical axis so it extends from 0 to 7. We will let it pick the range of the horizontal axis.
. This data corresonds to the motion of a ball thrown upwards. We expect this to have the form
+
[stem]
++++
y = y_0 + v_0 t - \frac{1}{2}gt^2
++++
+
so we want to fit a quadratic of the form
+
[stem]
++++
y = c_0 t^2 + c_1 t + c_2
++++
+
to the data. In the above equation the coefficients are arranged in the order used by the NumPy algorithm that is powering `prettyPolyFit`.
. Create a new Text cell **above** the cell producing the graph. In this type:
+
[source,markdown]
----
Model: $y = c_0 t^2 + c_1 t + c_2$
----
. Create a new Code cell **between** one with the equation and the cell producing the graph. This cell should contain:
+
[source,python]
----
fitTable1, fitFunc1 = buc.prettyPolyFit(df1['Time (s)'], df1['Height (m)'], deg=2, paramLabels=['c0', 'c1', 'c2'])
fitTable1
----
. The keyword parameter `deg` was used to set this to be a quadratic fit. We also needed to give it appropriate labels for the parameters (slope and intercept don't apply here).
. Edit the code cell for the graph, adding the following at the bottom:
+
[source, python]
----
t_fit = np.linspace(0,2.1,50);
ax1.plot(t_fit, fitFunc1(t_fit));
----
Notice that this time we need more points between our limits in the the `linspace` command. Using only two points to draw a quadratic would not turn out well! 50 points will make it look smooth enough.
. We now want to calculate the value of stem:[g] from this data. Comparing the two equations for height we see that
+
[stem]
++++
c_0 = -\frac{1}{2} g
++++
so stem:[g = -2 c_0]. The uncertainty in stem:[g], stem:[\delta g], will similarly be stem:[\delta g = 2 \delta c_0].
. Translating these into Python code we have:
+
[source, python]
----
g = -2*fitTable1.loc['value', 'c0']
dg = 2*fitTable1.loc['uncertainty', 'c0']
print("g = (%f Â± %f) m/s^2" % (g, dg))
----
. After seeing the preliminary results, we should edit the `print` command to produce the correct number of significant figures. In this case we want to display to the hundreths place so a `.2` should be placed between the `%` and the `f` at both locations inside of the quotation marks.

== Importing multiple sheets from an Excel workbook

. Create a Text cell with the section header `# Both trials`. In this section we will be exploring how to import multiple sheets from a workbook and perform repetitive operations on them.
. A _dictionary_ is one of Python's ways to have a collection of objects. In this case we will be creating a dictionary of DataFrames rather than just a single DataFrame. Items in a dictionary are not referred to by index, but by _key_ (a label). I will give it the name `dfd` to remind us that it is a DataFrame dictionary. We will use the `read_excel` command again but this time we tell it not to select any sheet in particular (but give us all of them) with the `None` keyword. After importing it we will ask for the keys in the dictionary. These should correspond to the names of the sheets in the Excel workbook.
. Create a Code cell with the following:
+
[source, python]
----
dfd = pd.read_excel("height-vs-time-data.xlsx", None)
dfd.keys()
----
. To select one of the DataFrames from the dictionary, we reference it by its key. For example:
+
[source, python]
----
dfd['Trial 2']
----

== Repeating tasks with loops

. We can then use Python's `for` loop to iterate over the dictionary's keys. Create a graph with both sets of data using the following:
+
[source, python]
----
fig2, ax2 = plt.subplots()
for key in dfd.keys():
  ax2.plot(dfd[key]['Time (s)'], dfd[key]['Height (m)'], 'D', label=key)
ax2.set_xlabel('Time (s)');
ax2.set_ylabel('Height (m)');
ax2.set_ylim(0, 8);
ax2.legend();
----
NOTE: The indentation following the `for` loop is critical in Python. Python uses indentation to indicate structure. The `for` loop ends when the indentation ends. This is different than C++ where structure is created with `{` and `}` and indentation was an optional kindness for the human reader.
. We can do something similar with the best fit portion of the analysis. Create a Code cell **above** the graph with the following.
+
[source, python]
----
fitTables = {}
fitFuncs = {}
for key in dfd.keys():
  fitTables[key], fitFuncs[key] = buc.prettyPolyFit(dfd[key]['Time (s)'], dfd[key]['Height (m)'], deg=2, paramLabels=['c0', 'c1', 'c2'])
----
. Dictionaries are created using curly braces. In this case we created empty dictionaries that were then filled in the `for` loop.
. Display the nicely formatted fitting parameter table for trial 1 by placing `fitTables['Trial 1']` in its own cell. If more than one thing with output is in single cell, only the last one is displayed.
. Now repeat for trial 2 (in its own cell).
. Alternatively, you can get both at once with a little more work:
+
[source, python]
----
for key in dfd.keys():
  display_markdown(f"### {key}", raw=True)
  display(fitTables[key])
  print()
----
. You will now edit the code cell for the graph to add the best fit curves. This modification has a few parts and the placement matters.
.. Immediately after the `fig2, ax2` line put a new line with the following:
+
[source, python]
----
t_fit = np.linspace(0, 2.5, 50)
----
.. Change the word `plot` to `scatter` in the original command for plotting the data. Also change the `'D'` to `marker='D'`. We are doing this so the automatic color selection algorithm will give both our data points and our best fit curves the same color.
.. Below the `ax2.scatter` command, add the following (at the same indentation level as `ax2.scatter` so it is also part of the `for` loop):
+
[source, python]
----
  ax2.plot(t_fit, fitFuncs[key](t_fit))
----
.. Process this revised code cell.
. Wrap up this lesson by saving this notebook to GitHub (menu:File[Save a copy in GitHub]).